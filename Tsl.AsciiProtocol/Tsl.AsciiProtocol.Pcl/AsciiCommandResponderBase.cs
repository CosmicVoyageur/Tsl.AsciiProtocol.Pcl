// Decompiled with JetBrains decompiler
// Type: TechnologySolutions.Rfid.AsciiProtocol.AsciiCommandResponderBase
// Assembly: TechnologySolutions.Rfid.AsciiProtocol.FX35, Version=1.1.5423.27429, Culture=neutral, PublicKeyToken=null
// MVID: 9C1072D5-BA32-4CFB-BB8E-6AC565EFDF12
// Assembly location: F:\Visual Studio\Repositories\IlukaOreSampleTracking\lib\Ascii 2 Windows\TechnologySolutions.Rfid.AsciiProtocol.FX35.dll

//using log4net;

using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Globalization;
using System.Text;
using Tsl.AsciiProtocol.Pcl.Commands;
using Tsl.AsciiProtocol.Pcl.Parameters;

namespace Tsl.AsciiProtocol.Pcl
{
  /// <summary>
  /// Base implmentation of <see cref="T:TechnologySolutions.Rfid.AsciiProtocol.IAsciiCommand"/>
  /// </summary>
  public abstract class AsciiCommandResponderBase
  {
    /// <summary>
    /// Provides logging for this class
    /// 
    /// </summary>
    //private static ILog log = LogManager.GetLogger(typeof (AsciiCommandResponderBase));
    /// <summary>
    /// The last received response to the command
    /// 
    /// </summary>
    private AsciiResponder response;
    /// <summary>
    /// True when the received line is between LB: and LE: headers
    /// 
    /// </summary>
    private bool isWithinLogResponse;

    /// <summary>
    /// Gets or sets the last command line generated by <see cref="M:PortableAscii2.AsciiCommandResponderBase.CommandLine"/>
    /// </summary>
    [Description("The command line as last sent to the reader")]
    [Category("Information")]
    public string LastCommandLine { get; set; }

    /// <summary>
    /// Gets the response received to this commmand for the last time it was executed
    /// 
    /// </summary>
    [Browsable(false)]
    [EditorBrowsable(EditorBrowsableState.Never)]
    public IAsciiResponseResponder Response
    {
      get
      {
        return (IAsciiResponseResponder) this.response;
      }
    }

    /// <summary>
    /// Gets the responder for the command that will populate <see cref="P:PortableAscii2.AsciiCommandResponderBase.Response"/>
    /// </summary>
    [EditorBrowsable(EditorBrowsableState.Never)]
    [Browsable(false)]
    public IAsciiCommandSynchronousResponder Responder
    {
      get
      {
        return (IAsciiCommandSynchronousResponder) this.response;
      }
    }

    /// <summary>
    /// Gets the parameters supported by this command
    /// 
    /// </summary>
    [EditorBrowsable(EditorBrowsableState.Never)]
    [Browsable(false)]
    public ParameterCollection Parameters { get; private set; }

    /// <summary>
    /// Gets the command name of the command (e.g. ".iv")
    /// 
    /// </summary>
    [Category("Information")]
    [Description("Identifies the command on the command line")]
    public string CommandName { get; private set; }

    /// <summary>
    /// Initializes a new instance of the AsciiCommandResponderBase class to respond to a specific command
    /// 
    /// </summary>
    /// <param name="commandName">The command name e.g. '.iv' for Inventory or string.Empty to respond to all commands</param>
    protected AsciiCommandResponderBase(string commandName)
    {
      this.CommandName = commandName;
      this.response = new AsciiResponder();
      this.Parameters = new ParameterCollection();
      this.response.MatchCommandLine = this.CommandName;
      this.isWithinLogResponse = false;
      this.Response.ReceivedLine += (EventHandler<AsciiLineEventArgs>) ((sender, e) =>
      {
        if (e.Line.Header.Equals("LB"))
          this.isWithinLogResponse = true;
        if (e.Line.Header.Equals("LE"))
          this.isWithinLogResponse = false;
        if (this.isWithinLogResponse || !AsciiResponseExtensions.IsParameters(e.Line))
          return;
        this.ParseParameters(e.Line.Value);
        e.Handled = true;
      });
    }

    /// <summary>
    /// Returns the Ascii command line (including terminators) to be sent to the device
    /// 
    /// </summary>
    /// 
    /// <returns>
    /// The command line to send this command
    /// </returns>
    public virtual string CommandLine()
    {
      StringBuilder stringBuilder = new StringBuilder();
      this.BuildCommandLine(stringBuilder);
      this.response.MatchCommandLine = stringBuilder.ToString();
      this.Parameters.AppendToCommandLine(stringBuilder);
      this.LastCommandLine = stringBuilder.ToString();
      return this.LastCommandLine;
    }

    /// <summary>
    /// Parses a PR: value for parameters and updates the command with the values parsed
    /// 
    /// </summary>
    /// <param name="parameterLine">The line containing parameters to parse</param>
    /// <returns>
    /// The individual parameters from the line
    /// </returns>
    /// TO x DO: upgrade to handle entire command line
    public IEnumerable<string> ParseParameters(string parameterLine)
    {
      //AsciiCommandResponderBase.log.InfoFormat("ParseParameters+ '{0}'", (object) parameterLine);
      IEnumerable<string> parameters;
      this.ValidateAndParseParameters(parameterLine, out parameters);
      //AsciiCommandResponderBase.log.Info((object) "ParseParameters-");
      return parameters;
    }

    /// <summary>
    /// Parses a command line or PR: value and updates the commands parameter to match.
    ///             Returns validation messages for any errors encountered
    /// 
    /// </summary>
    /// <param name="parameterLine">The parameters to parse</param>
    /// <returns>
    /// Any validtion messages arising from parsing the parameter line
    /// </returns>
    public ICollection<string> ValidateAndParseParameters(string parameterLine)
    {
      //AsciiCommandResponderBase.log.Info((object) "ValidateParameters+");
      IEnumerable<string> parameters;
      ICollection<string> collection = this.ValidateAndParseParameters(parameterLine, out parameters);
      //AsciiCommandResponderBase.log.Info((object) "ValidateParameters-");
      return collection;
    }

    /// <summary>
    /// Parses a command line or PR: value and updates the commands parameter to match.
    ///             Returns validation messages for any errors encountered
    /// 
    /// </summary>
    /// <param name="parameterLine">The parameters to parse</param><param name="parameters">output the parameter line split into individual parameters</param>
    /// <returns>
    /// Any validtion messages arising from parsing the parameter line
    /// </returns>
    protected virtual ICollection<string> ValidateAndParseParameters(string parameterLine, out IEnumerable<string> parameters)
    {
      //AsciiCommandResponderBase.log.InfoFormat("TryParseParameters+ '{0}'", (object) parameterLine);
      List<string> list = new List<string>();
      parameters = (IEnumerable<string>) CommandHelper.SplitParameters(parameterLine);
      this.Parameters.Reset();
      foreach (string parameter in parameters)
      {
        try
        {
          if (!this.Parameters.ParseParameter(parameter))
          {
            if (!parameter.StartsWith(this.CommandName, StringComparison.OrdinalIgnoreCase))
            {
              list.Add(string.Format((IFormatProvider) CultureInfo.CurrentUICulture, "Parameter '{0}' is not recognised for command {1}", new object[2]
              {
                (object) parameter,
                (object) this.CommandName
              }));
              //AsciiCommandResponderBase.log.WarnFormat("'{0}' paramter not recognised", (object) parameter);
            }
          }
        }
        catch (FormatException ex)
        {
          list.Add(ex.Message);
          //AsciiCommandResponderBase.log.Warn((object) "FormatException parsing parameter", (Exception) ex);
        }
        catch (ArgumentException ex)
        {
          list.Add(ex.Message);
          //AsciiCommandResponderBase.log.Warn((object) "ArgumentException parsing parameter", (Exception) ex);
        }
      }
      //AsciiCommandResponderBase.log.Info((object) "ParseParameters-");
      return (ICollection<string>) list;
    }

    /// <summary>
    /// Builds the command line part before the parameters. Appends the <see cref="P:PortableAscii2.AsciiCommandResponderBase.CommandName"/> to the command line
    /// 
    /// </summary>
    /// <param name="commandLine">The command line to append to</param>
    /// <remarks>
    /// Override this method to replace or append what gets written to the command line before the parameters.
    ///             When this responder is listening for the command start the "CS" value before the parameters must match
    ///             the built command line before the parameters for the command to be started.
    /// 
    /// </remarks>
    protected virtual void BuildCommandLine(StringBuilder commandLine)
    {
      commandLine.Append(this.CommandName);
    }
  }

}
